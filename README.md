# @robelest/convex-auth

Component-first authentication for Convex. Built around a reusable component boundary with full TypeScript support.

## Install

```bash
npm install @robelest/convex-auth
```

## Quick Setup (CLI)

The fastest way to get started is using the CLI, which scaffolds files and sets environment variables:

```bash
npx @robelest/convex-auth --site-url "http://localhost:5173"
```

The CLI will:
1. Set `SITE_URL` to your provided frontend app URL
2. Generate and set `JWT_PRIVATE_KEY` and `JWKS`
3. Update `tsconfig.json` (if needed)
4. Scaffold `convex/convex.config.ts` with component registration
5. Create `convex/auth.ts` with auth configuration
6. Create `convex/http.ts` with HTTP routes

After setup, configure your frontend and add providers as needed.

### CLI Options

| Option | Description |
|--------|-------------|
| `--site-url <url>` | Your frontend app URL. If omitted, CLI will prompt interactively |
| `--prod` | Target production deployment |
| `--preview-name <name>` | Target a specific preview deployment |
| `--deployment-name <name>` | Target a specific deployment by name |
| `--variables <json>` | Configure additional provider variables interactively |
| `--skip-git-check` | Skip Git repository check |
| `--allow-dirty-git-state` | Allow running with uncommitted changes |

**Examples:**

```bash
# Dev setup with explicit URL
npx @robelest/convex-auth --site-url "http://localhost:5173"

# Production setup
npx @robelest/convex-auth --prod --site-url "https://myapp.com"

# Preview deployment
npx @robelest/convex-auth --preview-name "feature-branch" --site-url "https://preview.myapp.com"
```

## Manual Setup

If you prefer manual setup, create these three files:

### 1. Register the auth component

`convex/convex.config.ts`

```ts
import { defineApp } from "convex/server";
import auth from "@robelest/convex-auth/convex.config";

const app = defineApp();
app.use(auth);

export default app;
```

### 2. Configure auth with providers

`convex/auth.ts`

```ts
import { Auth } from "@robelest/convex-auth/component";
import { components } from "./_generated/api";
import Password from "@robelest/convex-auth/providers/Password";

export const { auth, signIn, signOut, store } = Auth({
  component: components.auth,
  providers: [Password],
});
```

### 3. Wire up HTTP routes

`convex/http.ts`

```ts
import { httpRouter } from "convex/server";
import { auth } from "./auth";

const http = httpRouter();
auth.addHttpRoutes(http);

export default http;
```

Then manually set environment variables (see below).

## Environment Variables

### Required (Set These)

These must be set on **every deployment** (dev, preview, production):

| Variable | Set By | Purpose | Example |
|----------|--------|---------|---------|
| `JWT_PRIVATE_KEY` | CLI or manual | Signs session JWTs | _(generated by CLI)_ |
| `JWKS` | CLI or manual | JSON Web Key Set for JWT verification | _(generated by CLI)_ |
| `SITE_URL` | CLI or manual | Your frontend app URL. Used for OAuth/magic link redirects | `http://localhost:5173` (dev)<br>`https://myapp.com` (prod) |

**Set manually:**

```bash
# Dev deployment (default)
npx convex env set SITE_URL "http://localhost:5173"

# Production deployment
npx convex env set --prod SITE_URL "https://myapp.com"
```

**Generate keys manually:**

```bash
# Use the CLI to generate keys
npx @robelest/convex-auth
```

Or use the auth library's key generation utility directly in your Convex functions.

### System Variables (Auto-Provided)

These are automatically set by Convex — you never set them manually:

| Variable | Purpose |
|----------|---------|
| `CONVEX_SITE_URL` | Your deployment's HTTP actions URL (e.g., `https://your-deployment.convex.site`). Used as JWT issuer and OAuth callback base URL. |

### Provider Variables

OAuth providers require client ID and secret. Set these per deployment:

| Variable Pattern | Example | Purpose |
|-----------------|---------|---------|
| `AUTH_<PROVIDER>_ID` | `AUTH_GITHUB_ID` | OAuth client ID |
| `AUTH_<PROVIDER>_SECRET` | `AUTH_GITHUB_SECRET` | OAuth client secret |

**Example:**

```bash
# Dev
npx convex env set AUTH_GITHUB_ID "dev-client-id"
npx convex env set AUTH_GITHUB_SECRET "dev-client-secret"

# Production
npx convex env set --prod AUTH_GITHUB_ID "prod-client-id"
npx convex env set --prod AUTH_GITHUB_SECRET "prod-client-secret"
```

### Optional Variables

| Variable | Purpose | Default |
|----------|---------|---------|
| `AUTH_SESSION_TOTAL_DURATION_MS` | Max session lifetime (milliseconds) | 30 days |
| `AUTH_SESSION_INACTIVE_DURATION_MS` | Inactive session timeout (milliseconds) | _(provider-specific)_ |
| `AUTH_LOG_LEVEL` | Log verbosity: `DEBUG`, `INFO`, `WARN`, `ERROR` | `INFO` |
| `AUTH_LOG_SECRETS` | Set `"true"` to log secrets (dev only!) | `false` |
| `CUSTOM_AUTH_SITE_URL` | Override `CONVEX_SITE_URL` for OAuth callbacks (rare) | _(uses `CONVEX_SITE_URL`)_ |

## Deploy to Production

### One-Time Setup

Run the CLI targeting your production deployment:

```bash
npx @robelest/convex-auth --prod
```

The wizard will prompt for your production site URL and generate JWT keys.

Then set any provider secrets:

```bash
npx convex env set --prod AUTH_GITHUB_ID "your-prod-client-id"
npx convex env set --prod AUTH_GITHUB_SECRET "your-prod-client-secret"
```

### Deploy

Deploy your backend and frontend:

```bash
npx convex deploy --cmd 'npm run build'
```

This deploys your Convex functions and builds your frontend with the correct production deployment URL.

### Key Points

- **`SITE_URL` is per-deployment**: Dev uses `http://localhost:5173`, prod uses `https://myapp.com`
- **Keys are per-deployment**: Each deployment needs its own `JWT_PRIVATE_KEY` and `JWKS`
- **`CONVEX_SITE_URL` is auto-set**: Convex provides this — never set it manually
- **OAuth apps may differ**: You might have separate OAuth apps for dev and prod
- **Password-only auth works without `SITE_URL`**: Only OAuth and magic links need it

### Vercel / Netlify / Other Hosts

When deploying with `npx convex deploy --cmd 'npm run build'`, Convex will:

1. Set `CONVEX_URL` (or `VITE_CONVEX_URL`) for your frontend build
2. Build your frontend with the correct Convex deployment URL
3. Deploy your backend functions to Convex

Your hosting provider only needs the built frontend. Convex handles the backend separately.

## Backend Usage

Use `auth.user.*` helpers in your Convex functions:

```ts
import { query } from "./_generated/server";
import { auth } from "./auth";

export const viewer = query({
  args: {},
  handler: async (ctx) => {
    const userId = await auth.user.require(ctx);
    return await auth.user.get(ctx, userId);
  },
});
```

### Common Helpers

| Helper | Description |
|--------|-------------|
| `auth.user.current(ctx)` | Returns signed-in user ID or `null` |
| `auth.user.require(ctx)` | Returns user ID or throws if not signed in |
| `auth.user.get(ctx, userId)` | Fetches user document by ID via component API |
| `auth.user.viewer(ctx)` | Fetches the current signed-in user document |

User profiles include an optional `extend` JSON field for app-specific data (for example preferences, onboarding state, feature flags, or profile attributes).

Why `extend`?

- It gives you a stable extension point without changing auth table structure.
- It keeps app-specific JSON separate from auth core fields.
- It is consistent across `user`, `group`, `member`, and `invite`.

### Group and membership helpers

The component exposes a hierarchical `group` primitive.

- A root group has no `parentGroupId`.
- Child groups set `parentGroupId` to another group id.
- Roles are application-defined strings on membership records (for example: `owner`, `admin`, `member`, `viewer`).
- Groups, memberships, and invites each include an optional `extend` JSON field for custom app data.

```ts
import { mutation } from "./_generated/server";
import { auth } from "./auth";

export const createGroup = mutation({
  args: {},
  handler: async (ctx) => {
    const userId = await auth.user.require(ctx);
    const groupId = await auth.group.create(ctx, {
      name: "Acme",
      extend: { billingPlan: "pro", region: "us" },
    });

    await auth.group.member.add(ctx, {
      groupId,
      userId,
      role: "owner",
      status: "active",
      extend: { invitedVia: "seed-script" },
    });

    return groupId;
  },
});
```

Main group APIs:

- `auth.group.create(ctx, data)` creates a group.
- `auth.group.get(ctx, groupId)` fetches a group.
- `auth.group.list(ctx, { parentGroupId? })` lists root groups or children.
- `auth.group.update(ctx, groupId, data)` patches a group.
- `auth.group.delete(ctx, groupId)` deletes a group and cascades to descendants, members, and invites.

Membership APIs:

- `auth.group.member.add(ctx, data)` creates membership.
- `auth.group.member.get(ctx, memberId)` fetches membership by id.
- `auth.group.member.list(ctx, { groupId })` lists members for a group.
- `auth.group.member.update(ctx, memberId, data)` updates role/status/extend.
- `auth.group.member.remove(ctx, memberId)` removes membership.
- `auth.user.group.list(ctx, { userId })` lists all memberships for a user.
- `auth.user.group.get(ctx, { userId, groupId })` fetches one membership for a user in a group.

### Invite flow

Invites are platform-level records with statuses: `pending`, `accepted`, `revoked`, `expired`.
Use optional `groupId` when an invite should grant access to a specific group.

```ts
import { mutation } from "./_generated/server";
import { auth } from "./auth";

export const inviteUser = mutation({
  args: {},
  handler: async (ctx) => {
    const invitedByUserId = await auth.user.require(ctx);
    const inviteId = await auth.invite.create(ctx, {
      groupId: "group_id_here",
      invitedByUserId,
      email: "new-user@example.com",
      tokenHash: "hashed-token",
      status: "pending",
      expiresTime: Date.now() + 1000 * 60 * 60 * 24,
      role: "member",
      extend: { source: "admin-panel" },
    });
    return inviteId;
  },
});
```

Invite APIs:

- `auth.invite.create(ctx, data)` creates an invite.
- `auth.invite.get(ctx, inviteId)` fetches an invite.
- `auth.invite.list(ctx, { groupId?, status? })` lists invites.
- `auth.invite.accept(ctx, inviteId)` accepts a pending invite.
- `auth.invite.revoke(ctx, inviteId)` revokes a pending invite.

The component does not send emails by itself. Create invites in a mutation,
then trigger notifications using your app's provider of choice (for example,
Resend) in your app layer.

### Invite acceptance and membership (atomic pattern)

If an invite includes a `groupId`, accept + member creation should happen in
the same Convex mutation to keep state transactional.

```ts
import { ConvexError, v } from "convex/values";
import { mutation } from "./_generated/server";
import { auth } from "./auth";

export const acceptInvite = mutation({
  args: { inviteId: v.string() },
  handler: async (ctx, { inviteId }) => {
    const userId = await auth.user.require(ctx);
    const invite = await auth.invite.get(ctx, inviteId);
    if (!invite) throw new Error("Invite not found");

    await auth.invite.accept(ctx, inviteId);
    if (invite.groupId) {
      try {
        await auth.group.member.add(ctx, {
          groupId: invite.groupId,
          userId,
          role: invite.role,
        });
      } catch (error) {
        if (error instanceof ConvexError && error.data?.code === "DUPLICATE_MEMBERSHIP") {
          return { alreadyMember: true, memberId: error.data.existingMemberId };
        }
        throw error;
      }
    }

    return { success: true };
  },
});
```

`auth.group.member.add` throws `DUPLICATE_MEMBERSHIP` if the user already
belongs to the group. `auth.invite.create` throws `DUPLICATE_INVITE` when a
pending invite already exists for the same email and scope. `auth.invite.accept`
and `auth.invite.revoke` throw `INVITE_NOT_FOUND` or `INVITE_NOT_PENDING` for
invalid invite transitions.

## Component System

The auth runtime uses `component: components.auth` to execute storage and auth operations through a component API boundary.
This gives you a clean integration point and keeps auth primitives (users, accounts, sessions, verification, rate limits, and group/member/invite APIs) in one place.

- Clean integration point
- Isolated auth primitives (users, accounts, sessions, verification)
- Rate limiting and security features
- Group/member/invite APIs

All auth tables live inside the component — you don't need to modify your schema.

## Full Documentation

For complete documentation, see: https://deepwiki.com/robelest/convex-auth

## Roadmap

### Phase 1 — Complete Core Auth
- **Two-Factor Authentication (2FA)**: TOTP authenticator app support, backup codes, trusted devices
- **Passkeys / WebAuthn**: Passwordless authentication via biometrics and security keys (powered by SimpleWebAuthn)
- **Admin Operations**: User ban/unban, session listing and revocation, user impersonation
- **Account Deletion**: Full cascade across sessions, tokens, accounts, memberships, and invites

### Phase 2 — Developer Platform
- **API Keys**: Hashed key storage, CRUD, per-key rate limiting, scoped permissions, `x-api-key` header verification
- **One-Time Tokens**: Secure single-use tokens for cross-domain auth, magic actions, and email verification links
- **Device Authorization (RFC 8628)**: OAuth device flow for CLIs, smart TVs, and IoT devices
- **Bearer Token Auth**: `Authorization: Bearer` header support for API-first applications

### Phase 3 — OAuth Foundation
- **Migrate to Arctic**: Replace `@auth/core` with Arctic for a lighter, actively maintained OAuth 2.0 client layer with zero third-party dependencies

### Phase 4 — Enterprise SSO & Directory Sync
- **SSO (SAML 2.0 + OIDC)**: Register identity providers dynamically, sign in by domain/email/org, SAML assertion validation, OIDC discovery, attribute mapping (powered by samlify)
- **SCIM 2.0 Directory Sync**: User lifecycle management — provision, update, and deprovision users from Okta, Azure AD, Google Workspace, and other directory providers. Standard + custom attribute mapping, group sync, and provisioning/deprovisioning events
- **Domain Verification**: DNS TXT record verification for organization domain ownership
- **Organization Provisioning**: Auto-add SSO/SCIM users to groups with role mapping
- **Self-Serve Admin Portal** (`@robelest/convex-auth-portal`): Astro-powered UI served directly from Convex HTTP endpoints. IT admins configure SSO, SCIM, and domain verification through a guided wizard — no developer involvement needed. Generate a secure link, send it to your customer's IT team. Includes per-IdP setup guides for Okta, Azure AD, Google Workspace, OneLogin, JumpCloud, and custom SAML/OIDC. Supports branding customization (logo, colors, app name)

### Phase 5 — Be the Identity Provider
- **OAuth 2.1 Provider**: Authorization code flow with PKCE, client credentials, refresh tokens, dynamic client registration, token introspection and revocation
- **OIDC Provider**: id_token issuance, UserInfo endpoint, `.well-known/openid-configuration`
- **MCP Support**: Model Context Protocol authentication for AI agent integrations

### Phase 6 — Enterprise Hardening
- **Audit Logging**: Structured auth event log (sign-in, sign-out, password change, 2FA enable, admin actions) with actor/target/context tracking
- **Webhook Notifications**: Fire webhooks on auth lifecycle events (user created, session created, password changed, user provisioned via SCIM)
- **Advanced Rate Limiting**: IP-based brute force protection
- **OAuth Token Storage**: Store provider access/refresh tokens for apps that call provider APIs on behalf of users

---

## Contributing to This Repo

This section is for contributors working on the `@robelest/convex-auth` monorepo itself.

### Install Dependencies

```bash
bun install
```

### Start Convex Dev

```bash
bun run dev:convex
```

### Run Tests

```bash
bun run test:auth
```

### Monorepo Structure

- `packages/auth/` — Main auth package
- `packages/portal/` — Self-serve admin portal (Astro)
- `packages/test/` — Shared test suite
- `examples/tanstack/` — TanStack Start example app
- `convex/` — Root Convex functions for testing
